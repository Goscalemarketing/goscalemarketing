<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Hamburguesa AR · WebXR</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; touch-action:none; }
    #overlay {
      position:fixed; inset:0;
      display:flex; flex-direction:column; justify-content:space-between;
      pointer-events:none; color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    }
    #topbar {
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:12px;
      background:linear-gradient(to bottom, rgba(0,0,0,.65), rgba(0,0,0,0));
      pointer-events:auto;
    }
    .btn {
      pointer-events:auto;
      color:#fff; text-decoration:none;
      border:1px solid rgba(255,255,255,.2);
      background:rgba(255,255,255,.08);
      padding:10px 12px; border-radius:12px;
      font-weight:800; font-size:14px;
    }
    #hint {
      pointer-events:none;
      text-align:center;
      padding:14px 14px 18px;
      font-size:13px;
      background:linear-gradient(to top, rgba(0,0,0,.65), rgba(0,0,0,0));
      opacity:.95;
    }
    #hint b { font-weight:900; }
    #status {
      pointer-events:none;
      position:fixed; left:10px; bottom:10px;
      font-size:12px; padding:8px 10px;
      border-radius:10px; border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.45);
      max-width:70vw; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      opacity:.9;
    }
    canvas { display:block; }
  </style>
</head>

<body>
  <div id="overlay">
    <div id="topbar">
      <a class="btn" href="https://gastro.goscalemarketing.com/menu">← Menú</a>
      <span style="font-weight:900">Hamburguesa clásica</span>
      <a class="btn" href="https://goscalemarketing.com" target="_blank" rel="noopener">by GoScale</a>
    </div>

    <div id="hint">
      <div><b>1)</b> Apunta al suelo hasta ver el círculo</div>
      <div><b>2)</b> <b>Tap</b> para colocar</div>
      <div><b>3)</b> <b>Pinch</b> = tamaño · <b>Giro 2 dedos</b> = rotación</div>
    </div>
  </div>

  <div id="status">Preparando…</div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { GLTFLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";
    import { ARButton } from "https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js";

    // ====== URLs ======
    const GLB_URL  = "https://pub-83c24afb5cab45db860452e48428fdd5.r2.dev/Restaurante_Cuchara_Vieja/Hamburguesa/Hamburguesa.glb";
    const USDZ_URL = "https://pub-83c24afb5cab45db860452e48428fdd5.r2.dev/Restaurante_Cuchara_Vieja/Hamburguesa/Hamburguesa.usdz";

    // ====== Device detect ======
    const ua = navigator.userAgent;
    const isiOS = /iPad|iPhone|iPod/.test(ua);

    // iOS: Quick Look directo (mantener como funciona)
    if (isiOS) {
      window.location.href = USDZ_URL;
      // No seguimos ejecutando JS AR en iOS
    }

    const statusEl = document.getElementById("status");
    const setStatus = (t) => statusEl.textContent = t;

    // ====== Fallback Scene Viewer (si no hay WebXR AR) ======
    function openSceneViewer() {
      const intent =
        "intent://arvr.google.com/scene-viewer/1.0" +
        "?file=" + encodeURIComponent(GLB_URL) +
        "&mode=ar_preferred" +
        "&resizable=true" +
        "#Intent;scheme=https;package=com.google.android.googlequicksearchbox;end;";
      window.location.href = intent;
    }

    // ====== Check WebXR ======
    if (!navigator.xr) {
      setStatus("WebXR no disponible. Abriendo Scene Viewer…");
      openSceneViewer();
    }

    const isArSupported = await navigator.xr.isSessionSupported("immersive-ar").catch(() => false);
    if (!isArSupported) {
      setStatus("AR WebXR no soportado. Abriendo Scene Viewer…");
      openSceneViewer();
    }

    setStatus("WebXR AR listo. Pulsa START AR.");

    // ====== Three.js scene ======
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera();
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Light (simple; en AR el fondo es cámara)
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
    scene.add(hemi);

    // Reticle (círculo de colocación)
    const reticleGeom = new THREE.RingGeometry(0.08, 0.10, 32).rotateX(-Math.PI / 2);
    const reticleMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.85 });
    const reticle = new THREE.Mesh(reticleGeom, reticleMat);
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // Load model
    const loader = new GLTFLoader();
    let modelRoot = null;
    let placed = false;

    setStatus("Cargando hamburguesa…");
    loader.load(
      GLB_URL,
      (gltf) => {
        modelRoot = gltf.scene;
        modelRoot.visible = false;     // se muestra al colocar
        modelRoot.scale.setScalar(1);  // escala base
        scene.add(modelRoot);
        setStatus("Modelo cargado. START AR → apunta al suelo.");
      },
      undefined,
      (err) => {
        console.error(err);
        setStatus("Error cargando GLB. Revisa URL/CORS.");
      }
    );

    // ====== WebXR hit test ======
    let hitTestSource = null;
    let hitTestSourceRequested = false;

    const controller = renderer.xr.getController(0);
    scene.add(controller);

    controller.addEventListener("select", () => {
      if (!reticle.visible || !modelRoot) return;

      // Colocar modelo en el reticle
      modelRoot.visible = true;
      modelRoot.position.setFromMatrixPosition(reticle.matrix);

      // Orientación inicial (de pie); rotación solo Y
      const rot = new THREE.Quaternion().setFromRotationMatrix(reticle.matrix);
      modelRoot.quaternion.copy(rot);

      placed = true;
      setStatus("Colocada. Pinch = tamaño · Giro 2 dedos = rotación.");
    });

    // ====== Gestos custom (pinch/rotate) ======
    // Importante: sólo manipulamos cuando el modelo ya está colocado.
    const pointers = new Map();
    let startDist = 0;
    let startAngle = 0;
    let startScale = 1;
    let startYaw = 0;

    function getTwo() {
      return Array.from(pointers.values()).slice(0, 2);
    }
    function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
    function angle(a, b) { return Math.atan2(b.y - a.y, b.x - a.x); }

    function getYawRad() {
      if (!modelRoot) return 0;
      // yaw desde rotación Euler
      const e = new THREE.Euler().setFromQuaternion(modelRoot.quaternion, "YXZ");
      return e.y;
    }
    function setYawRad(yaw) {
      if (!modelRoot) return;
      const e = new THREE.Euler(0, yaw, 0, "YXZ");
      modelRoot.quaternion.setFromEuler(e);
    }

    function onPointerDown(e) {
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (pointers.size === 2 && placed && modelRoot) {
        const [p1, p2] = getTwo();
        startDist = dist(p1, p2);
        startAngle = angle(p1, p2);
        startScale = modelRoot.scale.x;
        startYaw = getYawRad();
      }
    }

    function onPointerMove(e) {
      if (!pointers.has(e.pointerId)) return;
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (pointers.size === 2 && placed && modelRoot) {
        e.preventDefault();

        const [p1, p2] = getTwo();
        const d = dist(p1, p2);
        const a = angle(p1, p2);

        // Escala (pinch)
        if (startDist > 0) {
          const factor = d / startDist;
          const newScale = THREE.MathUtils.clamp(startScale * factor, 0.2, 3.0);
          modelRoot.scale.setScalar(newScale);
        }

        // Rotación (twist) sobre eje Y
        const delta = a - startAngle;
        setYawRad(startYaw + delta);
      }
    }

    function onPointerUp(e) {
      pointers.delete(e.pointerId);
      if (pointers.size < 2) {
        startDist = 0;
        startAngle = 0;
      }
    }

    renderer.domElement.addEventListener("pointerdown", onPointerDown, { passive: false });
    renderer.domElement.addEventListener("pointermove", onPointerMove, { passive: false });
    renderer.domElement.addEventListener("pointerup", onPointerUp, { passive: false });
    renderer.domElement.addEventListener("pointercancel", onPointerUp, { passive: false });

    // ====== Render loop with hit test ======
    renderer.setAnimationLoop((timestamp, frame) => {
      if (frame) {
        const referenceSpace = renderer.xr.getReferenceSpace();

        // Pedir hit-test source una vez
        if (!hitTestSourceRequested) {
          const session = renderer.xr.getSession();
          session.requestReferenceSpace("viewer").then((viewerSpace) => {
            session.requestHitTestSource({ space: viewerSpace }).then((source) => {
              hitTestSource = source;
            });
          });

          session.addEventListener("end", () => {
            hitTestSourceRequested = false;
            hitTestSource = null;
            reticle.visible = false;
            placed = false;
            if (modelRoot) modelRoot.visible = false;
            setStatus("Sesión AR cerrada.");
          });

          hitTestSourceRequested = true;
        }

        if (hitTestSource) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          if (hitTestResults.length) {
            const hit = hitTestResults[0];
            const pose = hit.getPose(referenceSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
      }

      renderer.render(scene, camera);
    });

    // ====== Start AR button ======
    const arButton = ARButton.createButton(renderer, {
      requiredFeatures: ["hit-test"],
      optionalFeatures: ["dom-overlay"],
      domOverlay: { root: document.body }
    });

    // Estiliza el botón para que quede “app-like”
    arButton.style.position = "fixed";
    arButton.style.left = "50%";
    arButton.style.bottom = "70px";
    arButton.style.transform = "translateX(-50%)";
    arButton.style.padding = "14px 18px";
    arButton.style.borderRadius = "16px";
    arButton.style.border = "0";
    arButton.style.fontWeight = "900";
    arButton.style.background = "#fff";
    arButton.style.color = "#111";
    arButton.style.boxShadow = "0 12px 30px rgba(0,0,0,.45)";
    document.body.appendChild(arButton);

    // Resize
    window.addEventListener("resize", () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
